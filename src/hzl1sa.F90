PROGRAM HZL1SA
  USE BINIO
  USE XHZ
  USE OMP_LIB
  IMPLICIT NONE

  CHARACTER(LEN=FNL) :: FN
  INTEGER :: M,MM,N,NN,NSWP,CPR, LDY,LDW,LDZ, JSTRAT,NPAIRS,NSTEPS, NROT(2),INFO, I

  INTEGER, TARGET :: JS(JSMLEX)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: JS

  INTEGER, ALLOCATABLE, TARGET :: JSPAIR(:,:,:), J(:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: JSPAIR, J
  COMPLEX(KIND=SWP), ALLOCATABLE, TARGET :: Y(:,:),W(:,:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: Y,W
  COMPLEX(KIND=SWP), ALLOCATABLE :: Z(:,:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: Z
  REAL(KIND=SWP), ALLOCATABLE, TARGET :: E(:),EY(:),EW(:), SY(:),SW(:),SS(:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: E,EY,EW, SY,SW,SS

  IF (.NOT. VERIFY_MIN_MAX()) STOP 'MIN and/or MAX do NOT handle NaNs properly!'
  CPR = MAX(INT(OMP_GET_MAX_THREADS()),1)
  CALL READCL(FN, M, N, JSTRAT, NSWP, INFO)
  IF (INFO .NE. 0) STOP 'Error in READCL'
  NN = N + MOD(N,2)
  NPAIRS = NN / 2
  IF (NN .GT. M) THEN
     MM = NN
  ELSE
     MM = M
  END IF
  LDY = LDALIGN(MM, CALIGN)
  LDW = LDALIGN(MM, CALIGN)
  LDZ = LDALIGN(NN, CALIGN)

  SELECT CASE (JSTRAT)
  CASE (JSMENC,JSMMNC)
     CONTINUE
  CASE DEFAULT
     STOP 'JSTRAT not JSMENC(2) nor JSMMNC(4)'
  END SELECT
  CALL JSTRAT_INIT(JS, JSTRAT, NN, NSTEPS)
  IF (NSTEPS .LE. 0) STOP 'Error in JSTRAT_INIT'
  ALLOCATE(JSPAIR(2,NPAIRS,NSTEPS),STAT=INFO)
  !DIR$ VECTOR ALWAYS ALIGNED
  JSPAIR = 0
  IF (INFO .GT. 0) STOP 'Error allocating JSPAIR'
  CALL JSTRAT_SWEEP_NC(JS, NSTEPS, NPAIRS, JSPAIR, INFO)
  IF (INFO .NE. 0) STOP 'Error in JSTRAT_NEXT/UNPACK_NC'

  ALLOCATE(Y(LDY,NN),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating Y'
  !DIR$ VECTOR ALWAYS ALIGNED
  Y = C_ZERO

  ALLOCATE(W(LDW,NN),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating W'
  !DIR$ VECTOR ALWAYS ALIGNED
  W = C_ZERO

  ALLOCATE(J(MM),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating J'
  !DIR$ VECTOR ALWAYS ALIGNED
  J = 0

  CALL BIO_READ_ALL(FN, M, N, Y, LDY, W, LDW, J, INFO)
  IF (INFO .NE. 0) STOP 'Error in BIO_READ_ALL'

  ALLOCATE(Z(LDZ,NN),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating Z'
  !DIR$ VECTOR ALWAYS ALIGNED
  Z = C_ZERO

  ALLOCATE(E(NN),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating E'
  !DIR$ VECTOR ALWAYS ALIGNED
  E = S_ZERO

  ALLOCATE(EY(NN),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating EY'
  !DIR$ VECTOR ALWAYS ALIGNED
  EY = S_ZERO

  ALLOCATE(EW(NN),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating EW'
  !DIR$ VECTOR ALWAYS ALIGNED
  EW = S_ZERO

  ALLOCATE(SY(NN),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating SY'
  !DIR$ VECTOR ALWAYS ALIGNED
  SY = S_ZERO

  ALLOCATE(SW(NN),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating SW'
  !DIR$ VECTOR ALWAYS ALIGNED
  SW = S_ZERO

  ALLOCATE(SS(NN),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating SS'
  !DIR$ VECTOR ALWAYS ALIGNED
  SS = S_ZERO

  DO I = N+1, NN
     Y(I,I) = C_ONE
     W(I,I) = C_ONE
  END DO
  DO I = M+1, MM
     J(I) = 1
  END DO

  CALL XHZL1SA(MM,NN, Y,LDY, J, W,LDW, Z,LDZ, JS,JSPAIR, NSWP,CPR, E,EY,EW, SY,SW,SS, NROT,INFO)
  WRITE (UOUT,'(2(I6,A),I1,A,2(I3,A),I20,A,I20)') &
       M,',',N,',',JSTRAT,',',CPR,',',INFO,',',NROT(1),',',NROT(2)
  IF (INFO .LT. 0) STOP 'Error in XHZL1SA'
  CALL JSTRAT_FREE(JS)

  CALL BIO_WRITE_ALL(FN, M, N, Y, LDY, W, LDW, Z, LDZ, E, EY, EW, SS, SY, SW, INFO)
  IF (INFO .NE. 0) STOP 'Error in BIO_WRITE_ALL'

  IF (ALLOCATED(SS)) DEALLOCATE(SS)
  IF (ALLOCATED(SW)) DEALLOCATE(SW)
  IF (ALLOCATED(SY)) DEALLOCATE(SY)
  IF (ALLOCATED(EW)) DEALLOCATE(EW)
  IF (ALLOCATED(EY)) DEALLOCATE(EY)

  IF (ALLOCATED(E)) DEALLOCATE(E)
  IF (ALLOCATED(Z)) DEALLOCATE(Z)
  IF (ALLOCATED(J)) DEALLOCATE(J)
  IF (ALLOCATED(W)) DEALLOCATE(W)
  IF (ALLOCATED(Y)) DEALLOCATE(Y)

CONTAINS

  SUBROUTINE READCL(FN, M, N, JSTRAT, NSWP, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*), INTENT(OUT) :: FN
    INTEGER, INTENT(OUT) :: M, N, JSTRAT, NSWP, INFO

    CHARACTER(LEN=FNL) :: ARG
    INTEGER :: TMP

    INFO = 0
    IF (COMMAND_ARGUMENT_COUNT() .NE. 5) STOP 'hzl1sa.exe FN M N JSTRAT NSWP'

    CALL GET_COMMAND_ARGUMENT(1, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -1
       RETURN
    END IF
    FN = TRIM(ARG)
    IF (LEN_TRIM(FN) .LE. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(2, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF
    READ (ARG,*) M
    IF (M .LE. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(3, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF
    READ (ARG,*) N
    IF (N .LE. 0) THEN
       INFO = 3
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(4, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -4
       RETURN
    END IF
    READ (ARG,*) JSTRAT
    IF ((JSTRAT .LT. 0) .OR. (JSTRAT .GT. JSMMWC)) THEN
       INFO = 4
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(5, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -5
       RETURN
    END IF
    READ (ARG,*) NSWP
    IF (NSWP .LT. 0) THEN
       INFO = 5
       RETURN
    END IF
  END SUBROUTINE READCL

END PROGRAM HZL1SA
