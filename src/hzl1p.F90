PROGRAM HZL1P
  USE BINIO
  USE XHZ
  IMPLICIT NONE

  INTEGER, PARAMETER :: FNL = 20

  CHARACTER(LEN=FNL) :: FN
  INTEGER :: M,N,NSWP,CPR, LDY,LDW,LDZ, JSTRAT,NPAIRS,NSTEPS, NROT(2),INFO

  INTEGER, TARGET :: JS(JSMLEX)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: JS

  INTEGER, ALLOCATABLE, TARGET :: JSPAIR(:,:,:), J(:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: JSPAIR, J
  COMPLEX(KIND=SWP), ALLOCATABLE, TARGET :: Y(:,:),W(:,:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: Y,W
  COMPLEX(KIND=SWP), ALLOCATABLE :: Z(:,:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: Z
  REAL(KIND=SWP), ALLOCATABLE, TARGET :: E(:),EY(:),EW(:), SY(:),SW(:),SS(:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: E,EY,EW, SY,SW,SS

  CALL READCL(FN, M, N, JSTRAT, NSWP, CPR, INFO)
  IF (INFO .NE. 0) STOP 'Error in READCL'
  IF (N .GT. M) STOP 'N > M'
  INFO = MOD(N, 2)
  IF (INFO .NE. 0) STOP 'N mod 2 =/= 0'
  NPAIRS = N / 2
  LDY = LDALIGN(M, CALIGN)
  LDW = LDALIGN(M, CALIGN)
  LDZ = LDALIGN(N, CALIGN)

  SELECT CASE (JSTRAT)
  CASE (JSMENC,JSMMNC)
     CONTINUE
  CASE DEFAULT
     STOP 'JSTRAT not JSMENC(2) nor JSMMNC(4)'
  END SELECT
  CALL JSTRAT_INIT(JS, JSTRAT, N, NSTEPS)
  IF (NSTEPS .LE. 0) STOP 'Error in JSTRAT_INIT'
  ALLOCATE(JSPAIR(2,NPAIRS,NSTEPS),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating JSPAIR'
  CALL JSTRAT_SWEEP_NC(JS, NSTEPS, NPAIRS, JSPAIR, INFO)
  IF (INFO .NE. 0) STOP 'Error in JSTRAT_NEXT/UNPACK_NC'

  ALLOCATE(Y(LDY,N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating Y'
  !DIR$ VECTOR ALWAYS ALIGNED
  Y = C_ZERO

  ALLOCATE(W(LDW,N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating W'
  !DIR$ VECTOR ALWAYS ALIGNED
  W = C_ZERO

  ALLOCATE(J(M),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating J'
  !DIR$ VECTOR ALWAYS ALIGNED
  J = 0

  CALL BIO_READ_ALL(FN, M, N, Y, LDY, W, LDW, J, INFO)
  IF (INFO .NE. 0) STOP 'Error in BIO_READ_ALL'

  ALLOCATE(Z(LDZ,N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating Z'
  !DIR$ VECTOR ALWAYS ALIGNED
  Z = C_ZERO

  ALLOCATE(E(N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating E'
  !DIR$ VECTOR ALWAYS ALIGNED
  E = S_ZERO

  ALLOCATE(EY(N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating EY'
  !DIR$ VECTOR ALWAYS ALIGNED
  EY = S_ZERO

  ALLOCATE(EW(N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating EW'
  !DIR$ VECTOR ALWAYS ALIGNED
  EW = S_ZERO

  ALLOCATE(SY(N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating SY'
  !DIR$ VECTOR ALWAYS ALIGNED
  SY = S_ZERO

  ALLOCATE(SW(N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating SW'
  !DIR$ VECTOR ALWAYS ALIGNED
  SW = S_ZERO

  ALLOCATE(SS(N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating SS'
  !DIR$ VECTOR ALWAYS ALIGNED
  SS = S_ZERO

  CALL XHZL1P(M,N, Y,LDY, J, W,LDW, Z,LDZ, JS,JSPAIR, NSWP,CPR, E,EY,EW, SY,SW,SS, NROT,INFO)
  WRITE (UOUT,'(2(I6,A),I1,A,2(I3,A),I20,A,I20)') &
       M,',',N,',',JSTRAT,',',CPR,',',INFO,',',NROT(1),',',NROT(2)
  IF (INFO .LT. 0) STOP 'Error in XHZL1P'

  CALL BIO_WRITE_ALL(FN, M, N, Y, LDY, W, LDW, Z, LDZ, E, EY, EW, SS, SY, SW, INFO)
  IF (INFO .NE. 0) STOP 'Error in BIO_WRITE_ALL'

  IF (ALLOCATED(SS)) DEALLOCATE(SS)
  IF (ALLOCATED(SW)) DEALLOCATE(SW)
  IF (ALLOCATED(SY)) DEALLOCATE(SY)
  IF (ALLOCATED(EW)) DEALLOCATE(EW)
  IF (ALLOCATED(EY)) DEALLOCATE(EY)

  IF (ALLOCATED(E)) DEALLOCATE(E)
  IF (ALLOCATED(Z)) DEALLOCATE(Z)
  IF (ALLOCATED(J)) DEALLOCATE(J)
  IF (ALLOCATED(W)) DEALLOCATE(W)
  IF (ALLOCATED(Y)) DEALLOCATE(Y)

CONTAINS

  SUBROUTINE READCL(FN, M, N, JSTRAT, NSWP, CPR, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*), INTENT(OUT) :: FN
    INTEGER, INTENT(OUT) :: M, N, JSTRAT, NSWP, CPR, INFO

    CHARACTER(LEN=FNL) :: ARG
    INTEGER :: TMP

    INFO = 0
    IF (COMMAND_ARGUMENT_COUNT() .NE. 6) STOP 'hzl1p.exe FN M N JSTRAT NSWP CPR'

    CALL GET_COMMAND_ARGUMENT(1, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -1
       RETURN
    END IF
    FN = TRIM(ARG)
    IF (LEN_TRIM(FN) .LE. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(2, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF
    READ (ARG,*) M
    IF (M .LE. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(3, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF
    READ (ARG,*) N
    IF (N .LE. 0) THEN
       INFO = 3
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(4, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -4
       RETURN
    END IF
    READ (ARG,*) JSTRAT
    IF ((JSTRAT .LT. 0) .OR. (JSTRAT .GT. JSMMWC)) THEN
       INFO = 4
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(5, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -5
       RETURN
    END IF
    READ (ARG,*) NSWP
    IF (NSWP .LT. 0) THEN
       INFO = 5
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(6, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -6
       RETURN
    END IF
    READ (ARG,*) CPR
    IF (CPR .LE. 0) THEN
       INFO = 6
       RETURN
    END IF
  END SUBROUTINE READCL
END PROGRAM HZL1P
